<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Angular I18n Xliff Editor</title>
  <style>
    html,
    body {
      padding: 0;
    }

    [pending] {
      display: none !important;
    }

    [data-page-section] {
      margin-bottom: 10px;
    }

    [data-page-section]:last-child {
      margin-bottom: 0;
    }

    .ant-tag.tag-label {
      margin: 0;
    }

    .ant-table-header-column {
      width: 100%;
    }

    .source-title-column {
      display: flex;
      align-items: center;
    }

    .source-title-column>span {
      display: inline-block;
    }

    .ant-alert.editor-validation-message {
      margin-top: 5px;
    }
  </style>
</head>

<body>
  <div id="app" pending>
    <a-layout>
      <a-layout-content :style="{ margin: '10px', padding: '12px', background: '#fff', minHeight: '280px' }">
        <a-row type="flex" data-page-section="filter-section">
          <a-col :span="24">
            <label>Xliff Location:</label>
            <a-select style="min-width: 250px" placeholder="Select a file" @change="onSelectedFileChange">
              <a-select-option v-for="item in xliffFiles" :key="item.path">
                {{ item.name }}
              </a-select-option>
            </a-select>
            <label>Target Locale:</label>
            <a-select style="width: 120px;" placeholder="Select a target locale" @change="onSelectedTargetLocale">
              <a-select-option v-for="item in locales" :key="item">
                {{ item }}
              </a-select-option>
            </a-select>
            <a-button v-if="transUnitTable.loaded" @click="loadXliffContent">Reload</a-button>
          </a-col>
        </a-row>
        <a-row type="flex" data-page-section="table-section" v-if="selectedXliffFile && selectedTargetLocale">
          <a-col :span="24">
            <a-spin :spinning="xliffFileLoading" tip="Loading...">
              <a-table :columns="transUnitTable.columns" :data-source="transUnitTable.transUnits" :pagination="false"
                bordered>
                <!-- title slots -->
                <span class="source-title-column" slot="sourceTitle">
                  <span>Source ({{ transUnitTable.sourceLocale }})</span>
                  <span :style="{ flex: 'auto', 'margin-left': '10px' }">
                    <a-input placeholder="Enter keyword to search">
                      <a-icon slot="prefix" type="search" />
                    </a-input>
                  </span>
                </span>
                <span class="source-title-column" slot="targetTitle">
                  <span>Translation ({{ transUnitTable.targetLocale }})</span>
                  <span :style="{ flex: 'auto', 'margin-left': '10px' }">
                    <a-input placeholder="Enter keyword to search">
                      <a-icon slot="prefix" type="search" />
                    </a-input>
                  </span>
                  <span :style="{ 'margin-left': '10px' }">
                    <template v-for="(item, key) in transStateOptions">
                      <a-tooltip :title="item.name" placement="bottom">
                        <a-checkable-tag :key="item.state" :checked="searchOptions.state.indexOf(item.state) > -1"
                          @change="checked => selectStateFilter(item.state, checked)">
                          {{ item.abbr }}
                        </a-checkable-tag>
                      </a-tooltip>
                    </template>
                  </span>
                </span>
                <!-- row data slots -->
                <div slot="sourceColumn" slot-scope="record">
                  <template v-for="part in record.source_parts">
                    <span v-if="part.type == 'text'">{{ part.displayHtml }}</span>
                    <a-tag class="tag-label" color="orange" v-else-if="part.type == 'ph_tag'" :data-part-key="part.key">
                      {{ part.key }}
                    </a-tag>
                  </template>
                </div>
                <div slot="targetColumn" slot-scope="record">
                  <!-- translation editor -->
                  <div v-if="transUnitTable.editingUnit && transUnitTable.editingUnit.key === record.key"
                    ref='editor-div'>
                    <a-mentions autoFocus v-model="transUnitTable.editingUnit.editorValue" prefix="#"
                      @blur="editorBlur(record, $event)" @select="tagSelected" @change="editorValueChange">
                      <a-mentions-option v-for="meta in transUnitTable.editingUnit.availableTags" :value="meta.tag">
                        {{ meta.tag }}<template v-if="meta.count > 1"> &times; {{ meta.count }}</template>
                      </a-mentions-option>
                    </a-mentions>
                    <a-alert class="editor-validation-message" type="error" show-icon closable
                      v-if="transUnitTable.editingUnit.errors" message="Validation Failed">
                      <template slot='description'>
                        <p :style="{ 'margin-bottom': '3px' }" v-for="msg of transUnitTable.editingUnit.errors">
                          {{ msg }}
                        </p>
                      </template>
                    </a-alert>
                  </div>
                  <!-- translation display value -->
                  <div v-else @click="startTranslation(record, $event)">
                    <template v-for="(part, index) in record.target_parts">
                      <span v-if="part.type == 'text'">{{ part.displayHtml }}</span>
                      <a-tag class="tag-label" color="orange" v-else-if="part.type == 'ph_tag'"
                        :data-part-key="part.key">
                        {{ part.key }}
                      </a-tag>
                    </template>
                  </div>
                </div>
                <div slot="recordActions" slot-scope="record">

                </div>
              </a-table>
            </a-spin>
          </a-col>
        </a-row>
        <a-row v-else>
          <a-col :span="24">
            <a-alert message="No Xliff File Selected"
              description="Please select a xliff file and a target locale to start translation." type="info"
              show-icon />
          </a-col>
        </a-row>
      </a-layout-content>
    </a-layout>
  </div>
  <script>
    const transUnitTableColumns = [
      {
        key: 'source',
        slots: {
          title: 'sourceTitle',
        },
        scopedSlots: {
          customRender: 'sourceColumn',
        },
        width: '45%'
      },
      {
        key: 'target',
        slots: { title: 'targetTitle' },
        scopedSlots: { customRender: 'targetColumn' },
        width: '45%'
      },
      {
        key: 'actions',
        title: 'Actions',
        scopedSlots: { customRender: 'recordActions' },
      }
    ];
    var mockDataModuleName = './mock-data';
    var isInVsCodeIDE = typeof acquireVsCodeApi === 'function';
    // var vscode = null;
    // try {
    //   vscode = acquireVsCodeApi();
    //   isInVsCodeIDE = true;
    // } catch (e) {

    // }
    let mainJsLocation = '#main#';
    let mockDataJsLocation = '#mockData#';
    if (mainJsLocation === '#main#') {
      mainJsLocation = './main.js';
    }
    if (mockDataJsLocation === '#mockData#') {
      mockDataJsLocation = mockDataModuleName + '.js';
    }
    const localResources = {
      // localCss: '../../out/i18nTranslateWebView/main.css',
      antdCss: '../../libs/ant-design-vue/1.6.2/antd.min.css',
      antdJs: '../../libs/ant-design-vue/1.6.2/antd.js',
      vueJs: '../../libs/vue/2.6.11/vue.js',
      momentJs: '../../libs/moment/2.27.0/moment-with-locales.min.js',
    };
    const config = {
      antdCss: '#vueAntdCssSrc#',
      antdJs: '#vueAntdJsSrc#',
      vueJs: '#vueJsSrc#',
      momentJs: '#momentJsSrc#',
      // localCss: '#localCssSrc#',
    };

    config.antdCss = config.antdCss !== '#vueAntdCssSrc#' ? config.antdCss : localResources.antdCss;
    config.antdJs = config.antdJs !== '#vueAntdJsSrc#' ? config.antdJs : localResources.antdJs;
    config.vueJs = config.vueJs !== '#vueJsSrc#' ? config.vueJs : localResources.vueJs;
    config.momentJs = config.momentJs !== '#momentJsSrc#' ? config.momentJs : localResources.momentJs;
    const states = [false, false, false, false];


    let exports = window.exports || undefined;
    let require = window.require || undefined;

    var loadAntd = function () {
      if (states[0] && states[1] && states[2]) {
        loadScriptOrStyle('script', config.antdJs, () => {
          if (!exports) {
            exports = { "__esModule": true };
          }
          if (!require) {
            require = function (m) {
              return require.modules[m];
            }
            require.modules = {};
            require.modules['vue'] = { default: Vue };
            require.modules['ant-design-vue'] = antd;
          }


          var startApp = function (mockData) {
            require.modules[mockDataModuleName] = mockData;
            loadScriptOrStyle('script', mainJsLocation, function () {
              bootstrap();
            });
          }

          if (isInVsCodeIDE) {
            startApp(null);
          } else {
            loadScriptOrStyle('script', mockDataJsLocation, () => {
              startApp({ 'MOCK_DATA': exports.MOCK_DATA });
            });
          }
        });
      }
    }

    loadScriptOrStyle('script', config.momentJs, () => {
      states[0] = true;
      loadAntd();
    });

    loadScriptOrStyle('script', config.vueJs, () => {
      states[1] = true;
      loadAntd();
    });

    loadScriptOrStyle('style', config.antdCss, () => {
      states[2] = true;
      loadAntd();
    });

    function loadScriptOrStyle(type, src, cb) {
      var head = document.getElementsByTagName('head')[0];
      var tag = null;
      if (type === 'script') {
        tag = document.createElement('script');
        tag.type = 'text/javascript';
        tag.src = src;
      } else if (type === 'style') {
        tag = document.createElement('link');
        tag.rel = 'stylesheet';
        tag.href = src;
      }

      if (tag != null) {
        // then bind the event to the callback function 
        // there are several events for cross browser compatibility
        var cbFunc = function () {
          cb();
        };
        tag.onreadystatechange = cbFunc;
        tag.onload = cbFunc;
        head.appendChild(tag);
      }
    }
  </script>
</body>

</html>